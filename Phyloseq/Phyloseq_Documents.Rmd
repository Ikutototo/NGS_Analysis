---
title: "Phyloseq_Documents"
author: "Saito Ikuto"
date: "`r Sys.Date()`"
output: 
  html_document: 
    df_print: tibble
    toc: yes
    toc_depth: 4
    toc_float: true
    highlight: "haddock"
---

Paper: **The phyllosphere microbiome shifts toward combating melanose pathogen**    
All the raw sequencing data from this project are available in the NCBI Sequence Read Archive (SRA) database under BioProject **PRJNA643596**

```{r setup, message=FALSE, eval=FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
knitr::opts_knit$set(root.dir = "/Users/saitoikuto/Documents/015.RStudio/NGS_Practice/The phyllosphere microbiome shifts toward combating melanose pathogen")

library(phyloseq); packageVersion("phyloseq")
library(Biostrings); packageVersion("Biostrings")
library(ggplot2); packageVersion("ggplot2")
library(tidyverse); packageVersion("tidyverse")

load(file = "start_phyloseq.RData")

```

## phyloseq: Explore microbiome profiles using R    

The phyloseq package is a tool to import, store, analyze, and graphically display complex phylogenetic sequencing data that has already been clustered into Operational Taxonomic Units (OTUs), especially when there is associated sample data, phylogenetic tree, and/or taxonomic assignment of the OTUs   

More concretely, phyloseq provides:   

*   Import abundance and related data from popular Denoising / OTU-clustering pipelines: (DADA2, UPARSE, QIIME, mothur, BIOM, PyroTagger, RDP, etc.)   
*   Convenience analysis wrappers for common analysis tasks
44 supported distance methods (UniFrac, Jensen-Shannon, etc)    
*   Ordination –> many supported methods, including constrained methods
*   Microbiome plot functions using ggplot2 for powerful, flexible exploratory analysis   
*   Modular, customizable preprocessing functions supporting fully reproducible work    
*   Functions for merging data based on OTU/sample variables, and for supporting manually-imported data    *    Native R/C, parallelized implementation of UniFrac distance calculations   
*   Multiple testing methods specific to high-throughput amplicon sequencing data   
*   Examples for analysis and graphics using real published data

### phyloseq-ize Data already in R    

**If you can get the data into R, then you can get it “into” phyloseq**   

Constructors:   

`otu_table`:    
Works on any numeric matrix. You must also specify if the species are rows or columns   

`sample_data`:    
Works on any data.frame. The rownames must match the sample names in the otu_table if you plan to combine them as a phyloseq-object   

`tax_table`:    
Works on any character matrix. The rownames must match the OTU names (taxa_names) of the otu_table if you plan to combine it with a phyloseq-object   

`phyloseq`:   
Takes as argument an otu_table and any unordered list of valid phyloseq components: sample_data, tax_table, phylo, or XStringSet. The tip labels of a phylo-object (tree) must match the OTU names of the otu_table, and similarly, the sequence names of an XStringSet object must match the OTU names of the otu_table   

**`merge_phyloseq`:**   
Can take any number of phyloseq objects and/or phyloseq components, and attempts to combine them into one larger phyloseq object. This is most-useful for adding separately-imported components to an already-created phyloseq object   


Note:   
OTUs and samples are included in the combined object only if they are present in all components. For instance, extra “leaves” on the tree will be trimmed off when that tree is added to a phyloseq object   



### Accessors   
Components of a phyloseq object, like the OTU Table, can be accessed by special accessor functions, or ``accessors’’, which return specific information about phylogenetic sequencing data, if present   
These accessor functions are available for direct interaction by users and dependent functions/packages   

`ntaxa`: Number of ASVs   
`nsamples`: Number og Samples    
`sample_names`    
`rank_names`    
`sample_variables`
`access`: access ASV table    
`otu_table`   
`tax_table`   
`phy_tree`    
**`taxa_names`**    
`taxa_are_rows`: t(physeq) → tax_table (taxa,ASV) Table → TRUE    


### Preprocessing   
The phyloseq package also includes functions for **filtering, subsetting, and merging abundance data**    
Filtering in phyloseq is designed in a modular fashion similar to the approach in the **genefilter package**    

This includes the `prune_taxa` and `prune_samples` methods for directly removing unwanted indices, as well as the `filterfun_sample` and `genefilter_sample` functions for building arbitrarily complex sample-wise filtering criteria, and the **`filter_taxa`** function for taxa-wise filtering    
First transformed to relative abundance, which is then filtered such that only OTUs with a mean greater than 10^-5 are kept   

For transforming abundance values by an arbitrary R function, phyloseq includes the **`transform_sample_counts`** function    
It takes as arguments a phyloseq-object and an R function, and returns a phyloseq-object in which the abundance values have been transformed, sample-wise, according to the transformations specified by the function

The subsetting methods `prune_taxa` and `prune_samples` are for cases where the complete subset of desired OTUs or samples is directly available    

Alternatively, the `subset_taxa` and `subset_samples` functions are for subsetting based on auxiliary data contained in the Taxonomy Table or Sample Data components, respectively    
These functions are analogous to the subset function in core R, in which the initial data argument is followed by an arbitrary logical expression that indicates elements or rows to keep    
Thus, entire experiment-level data objects can be subset according to conditional expressions regarding the auxiliary data   

Merging methods include `merge_taxa` and `merge_samples`, intended for merging specific OTUs or samples, respectively    
There is also the `merge_phyloseq` function for a complete merge of two or more phyloseq-objects (or a phyloseq-object and one or more separate components)   

Building on the `merge_taxa` methods, the phyloseq-package includes the agglomeration functions, `tip_glom` and `tax_glom`, for merging all OTUs in an experiment that are similar beyond a phylogenetic or taxonomic threshold, respectively    


#### EN_EP_phyloseq_Preprocess

```{r, eval=FALSE}

# Phylum!="Cyanobacteria" or Order!="Chloroplast" → Family == NAも除去
EN_EP_subset = subset_taxa(EN_EP_phyloseq, Order!="Chloroplast")
EN_EP_subset = subset_taxa(EN_EP_subset, Family!="Mitochondria")

# convert relative abundunces
EN_EP_RA = transform_sample_counts(EN_EP_subset, function(x) x / sum(x) )

# ASVs filtering 0.001 > → 
EN_EP_RA_filt = filter_taxa(EN_EP_RA, function(x) mean(x) > 0.001, TRUE)



# Standardize abundances to the median sequencing depth
total = median(sample_sums(EN_EP_subset))
standf = function(x, t=total) round(t * (x / sum(x)))
EN_EP_subset_z = transform_sample_counts(EN_EP_subset, standf)

# Filter the taxa using a cutoff of 3.0 for the Coefficient of Variation
EN_EP_subset_cv = filter_taxa(EN_EP_subset_z, function(x) sd(x)/mean(x) > 3.0, TRUE)

write.csv(x = t(EN_EP_subset@otu_table@.Data), file = "EN_EP_subset.csv")

```

#### EN_phyloseq_Preprocess


#### EP_phyloseq_Preprocess
```{r,eval=FALSE}
setwd("/Users/saitoikuto/Documents/015.RStudio/NGS_Practice/The phyllosphere microbiome shifts toward combating melanose pathogen")

library(phyloseq); packageVersion("phyloseq")
library(Biostrings); packageVersion("Biostrings")
library(ggplot2); packageVersion("ggplot2")
library(tidyverse); packageVersion("tidyverse")

load(file = "start_phyloseq.RData")

EP_subset = subset_taxa(EP_phyloseq, Order!="Chloroplast")
EP_subset = subset_taxa(EP_subset, Family!="Mitochondria")

EP_RA = transform_sample_counts(EP_subset, function(x) x / sum(x) )

EP_RA_filt <- filter_taxa(EP_RA, function(x) mean(x) > 0.001, TRUE)
# 2回目の相対存在量変換
EP_RA_filt = transform_sample_counts(EP_RA_filt, function(x) x / sum(x) )

taxa <- as.data.frame(EP_RA_filt@tax_table@.Data)

EP_RA_filt_data <- as.data.frame(t(EP_RA_filt@otu_table@.Data)) %>% 
  select(contains("EP_16S_D"), everything())

Mean_infected <- EP_RA_filt_data %>% 
  select(contains("EP_16S_D")) %>% 
  t() %>% 
  as.data.frame() %>% 
  mutate_all(~ . * 100) %>% 
  apply(., 2, mean)

EP_RA_filt_data <- EP_RA_filt_data %>% 
  mutate(Mean_infected = Mean_infected)

Mean_uninfected <- EP_RA_filt_data %>% 
  select(contains("EP_16S_H")) %>% 
  t() %>% 
  as.data.frame() %>% 
  mutate_all(~ . * 100) %>% 
  apply(., 2, mean)

EP_RA_filt_data <- EP_RA_filt_data %>% 
  mutate(Mean_uninfected = Mean_uninfected)

Mean_all <- EP_RA_filt_data %>% 
  select(contains("EP_16S")) %>% 
  t() %>% 
  as.data.frame() %>% 
  mutate_all(~ . * 100) %>% 
  apply(., 2, mean)

EP_RA_filt_data <- EP_RA_filt_data %>% 
  mutate(Mean_all_samples = Mean_all)

EP_RA_filt_data <- bind_cols(EP_RA_filt_data, taxa)

rm(list = setdiff(ls(), "EP_RA_filt_data"))
              
EP_RA_filt_data[1,][grep("EP_16S_D", colnames(EP_RA_filt_data), value = TRUE)]

EP_RA_filt_data$p.value <- EP_RA_filt_data %>% 
  dplyr::select(!c(Mean_infected, Mean_uninfected)) %>% 
  apply(., 1, \(x){
  EP_D <- as.numeric(x[grep("EP_16S_D", colnames(EP_RA_filt_data), value = TRUE)])
  EP_H <- as.numeric(x[grep("EP_16S_H", colnames(EP_RA_filt_data), value = TRUE)])
  result <- wilcox.test(EP_D,EP_H)
  result$p.value
})

EP_RA_filt_data <- EP_RA_filt_data %>% 
  mutate(log10_p.value = log10(p.value)) %>% 
  mutate(log2_FoldChange = log2(Mean_infected/Mean_uninfected)) 
  
EP_RA_filt_data$ASV_ID <- rownames(EP_RA_filt_data)


EP_RA_filt_data$diff <- EP_RA_filt_data %>% 
  dplyr::select(c(p.value, log2_FoldChange)) %>% 
  apply(., 1, \(x){
    if (x["p.value"] > 0.05) {
      "NotSig"
    } else if(x["log2_FoldChange"] < 0){
      "Depleted"
    } else{
      "Enriched"
    }
  }) 

EP_RA_filt_data <- EP_RA_filt_data %>% 
  mutate(Mean_all = Mean_infected + Mean_uninfected)

EP_RA_filt_data <- EP_RA_filt_data %>% 
  select(ASV_ID, log2_FoldChange, p.value, log10_p.value,
         diff, Kingdom, Phylum, Class, Order, Family, Genus, Species,
         Mean_infected, Mean_uninfected, Mean_all, Mean_all_samples, everything())

rownames(EP_RA_filt_data) <- NULL

write.csv(x = EP_RA_filt_data, file = "final_data.csv", row.names = FALSE)

ggplot(EP_RA_filt_data, aes(
  x = Genus, y = log10_p.value, 
  size = log10_p.value,
  shape = as.factor(case_when(
    diff == "NotSig" ~ 16, 
    diff == "Depleted" ~ if_else(ratio < 0.8, 25, 6), # FALSEになるASVがない
    diff == "Enriched" ~ if_else(ratio > 1.5, 24, 17) # FALSEになるASVがない
  )))) + 
  geom_hline(
    yintercept = -log10(0.05), color = "grey40",
    linetype = "dashed"
  ) +
  geom_point(alpha = 0.8, position = position_jitter(width = 1),
             aes(color = as_factor(Genus))) +
  theme_minimal() +
  theme(
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.y = element_markdown(),
    axis.text.x = element_text(angle = 60, size = 8, vjust = 0.5)
  )


```


### The distance function   

The `distance` function takes a phyloseq-class object and method option, and returns a `dist`-class distance object suitable for certain ordination methods and other distance-based analyses    
There are currently 44 explicitly supported method options in the phyloseq package, as well as user-provided arbitrary methods via an interface to **`vegan::designdist`**    
For the complete list of currently supported options/arguments to the method parameter, type `distanceMethodList` in the command-line of your R session    
Only sample-wise distances are currently supported (the type argument), but eventually OTU-wise (e.g. species) distances will be supported as well   

The available distance methods coded in `distance`

```{r, message=FALSE}

library("phyloseq"); packageVersion("phyloseq")
library("ggplot2"); packageVersion("ggplot2")
library("plyr"); packageVersion("plyr")

dist_methods <- unlist(distanceMethodList)
print(dist_methods)

```


Remove the two distance-methods that require a tree, and the generic custom method that requires user-defined distance arguments
```{r}

# All distance metrics → Comparison

# These require tree
dist_methods[(1:3)]
# Remove them from the vector
dist_methods <- dist_methods[-(1:3)]
# This is the user-defined method:
dist_methods["designdist"]
# Remove the user-defined distance
dist_methods = dist_methods[-which(dist_methods=="ANY")]



```


### phyloseq:: plot_??    

#### plot_tree

#### plot_bar   

#### plot_heatmap

####


```{r}

sessionInfo()

```

